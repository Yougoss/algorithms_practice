# coding: utf-8

# 2.1-1

'''
A=[31,41,59,26,41,58]
排序过程
31,41(i),59,26,41,58
31,41,59(i),26,41,58
31,41,26(i),59,41,58
31,26(i),41,59,41,58
26(i),31,41,59,41,58
26,31,41,41(i),59,58
26,31,41,41,58(i),59
'''

# ----------------------------------------------------------------------------------------------------------------------
# 2.1-2
# def insertion_sort(l):
#     for i in range(1, len(l)):
#         key = l[i]
#         j = i - 1
#         while j >= 0 and l[j] < key:
#             l[j+1] = l[j]
#             j -= 1
#         l[j+1] = key
#
# A = [31, 41, 59, 26, 41, 58]
#
# insertion_sort(A)
# print A

# ----------------------------------------------------------------------------------------------------------------------
# 2.1-3

#
# def search(l, v):
#     result = 'NIL'
#     for i in range(len(l)):
#         if l[i] == v:
#             result = i
#             break
#     return result
#
#
# L = [1, 2, 3, 3, 4]
# print 'i =', search(L, 3)
# print 'i =', search(L, 5)
#
# '''
# 循环不变式:
#     初始化(循环第一次迭代前):
#         第一次循环前, 没有找到,结果为NIL,成立
#
#     保持(如果循环某次迭代前为真,下次迭代仍然为真)
#         如果某次循环成立,如果没有break,则下次循环仍然是符合元素值为v的时候跳出循环返回记过,成立
#
#     终止(循环终止时,提供了一个有用的性质)
#         循环终止两种情况:
#             如果break,说明找到符合要求的角标,成立
#             如果是角标超出数组长度则说明没有找到,返回NIL,成立
#
# '''
#
#
# ----------------------------------------------------------------------------------------------------------------------
# 2.1-4
# A = [0, 0, 0, 1, 1, 0, 1, 1]    # 27
# B = [0, 0, 0, 0, 0, 1, 1, 1]    # 7
#
# # 形式化描述不会
# def binary_add(A, B):
#     length = len(A)
#     C = []
#     carry_bit = 0
#     for i in range(length-1, -1, -1):
#         bit1 = A[i]
#         bit2 = B[i]
#         bit_sum = bit1 + bit2 + carry_bit
#         if bit_sum < 2:
#             carry_bit = 0
#             C.append(bit_sum)
#         else:
#             carry_bit = 1
#             C.append(bit_sum - 2)
#     C.reverse()
#     return C
#
# print binary_add(A, B)
#
#


# ----------------------------------------------------------------------------------------------------------------------
# 2.2-1
'''
Θ(n^3)
'''
# ----------------------------------------------------------------------------------------------------------------------
# 2.2-2


# def swap(L, i, j):
#     temp = L[i]
#     L[i] = L[j]
#     L[j] = temp
#
#
# # 选择算法:找出数组中最小的元素与第一个元素交换,第二小的跟第二个元素交换...依次类推
# def select_sort(L):                     # 执行次数
#     n = len(L)
#     for i in range(n):                  # n
#         index = i                           # 1
#         for j in range(i, n):               # n-i(ti)
#             if L[j] < L[index]:             # n-i(ti)
#                 index = j                   # n-i(ti)
#         swap(L, i, index)                   # 1
#     return L
#
# A = [31, 41, 59, 26, 41, 58]
# print select_sort(A)


# ----------------------------------------------------------------------------------------------------------------------
# 并归算
# 采用了分治法的思想
'''
思路
1 当前数组长度大于一的时候,分成长度基本相等的两个数组
2 对两个数组排序
3 将两个排序好的数组中的元素合成一个数组(判断两个数组最小元素哪个更小,将最小的移到新数组,再比较之后两个最小的两个,将最小的添加到新数组,以此类推)
'''


def merge(arr, start, mid, end):
    pass


def merge_sort(arr, start, end):
    mid = int((start + end)/2)

    merge_sort(arr, start, mid)
    merge_sort(arr, mid+1, end)

    merge(arr, start, mid, end)



a = [1, 2, 3, 4, 5]

print merge_sort(a, 0, len(arr))